/**
 * @file McRTOS_startup.c
 *
 * McRTOS startup module.
 *
 * @author German Rivera 
 */ 

#include "McRTOS.h"
#include "McRTOS_internals.h"
#include "failure_data_capture.h"
#include "hardware_abstractions.h"
#include "utils.h"

TODO("Remove these pragmas")
#pragma GCC diagnostic ignored "-Wunused-function"

/**
 * Application thread priorities
 */
enum system_thread_priorities
{
    RTOS_ROOT_THREAD_PRIORITY = 0,
    RTOS_COMMAND_LINE_THREAD_PRIORITY = 1,
    TOUCH_SCREEN_READER_THREAD_PRIORITY = RTOS_LOWEST_THREAD_PRIORITY - 6,
    BUTTONS_READER_THREAD_PRIORITY = RTOS_LOWEST_THREAD_PRIORITY - 5,
    TRIMPOT_READER_THREAD_PRIORITY = RTOS_LOWEST_THREAD_PRIORITY - 4,
    RTOS_IDLE_THREAD_PRIORITY = RTOS_LOWEST_THREAD_PRIORITY,
};

#define RTOS_COMMAND_LINE_CONSOLE_CHANNEL   UINT8_C(1)

#define RTOS_CPU_CONTROLLER_INITIALIZER(_cpu_id) \
        .rts_cpu_controllers[_cpu_id] =                                 \
        {                                                               \
            .cpc_signature = RTOS_CPU_CONTROLLER_SIGNATURE,             \
            .cpc_cpu_id = (_cpu_id),                                    \
            .cpc_current_execution_context_p = NULL,                    \
            .cpc_current_thread_p = NULL,                               \
            .cpc_runnable_thread_priorities = 0,                        \
            .cpc_active_interrupts = 0,                                 \
            .cpc_nested_interrupts_count = 0,                           \
            .cpc_thread_scheduler_calls = 0,                            \
            .cpc_accumulated_thread_scheduler_overhead = 0,             \
            .cpc_interrupts_disabled_being_measured_count = 0,          \
            .cpc_startup_completed = false,                             \
            .cpc_pending_thread_time_slice_decrement = false,           \
            .cpc_current_timer_wheel_spoke_index = 0,                   \
            .cpc_ticks_since_boot_count = 0,                            \
            .cpc_interrupts_disabled_start_time_stamp = 0,              \
            .cpc_longest_time_interrupts_disabled = 0,                  \
            .cpc_latest_measurement_time_interrupts_disabled = 0,       \
            .cpc_app_config_p = NULL,                                   \
            .cpc_current_console_channel = 0,                           \
            .cpc_current_lcd_channel = 0,                               \
            FDC_INFO_INITIALIZER(.cpc_failures_info),                   \
            .cpc_execution_contexts_list_anchor =                       \
                GLIST_NODE_INITIALIZER(                                 \
                    g_McRTOS.rts_cpu_controllers[_cpu_id].              \
                        cpc_execution_contexts_list_anchor),            \
            .cpc_preemption_chain_anchor =                              \
                GLIST_NODE_INITIALIZER(                                 \
                    g_McRTOS.rts_cpu_controllers[_cpu_id].              \
                        cpc_preemption_chain_anchor),                   \
        }


static fdc_error_t rtos_root_thread_f(void *arg);
static fdc_error_t rtos_idle_thread_f(void *arg);
static fdc_error_t rtos_touch_screen_reader_thread_f(void *arg);
static fdc_error_t rtos_buttons_reader_thread_f(void *arg);
static fdc_error_t rtos_trimpot_reader_thread_f(void *arg);
static fdc_error_t rtos_command_line_thread_f(void *arg);
static void McRTOS_display_help(void);
static void McRTOS_display_stats(void);

static const char g_McRTOS_version[] = "McRTOS v0.03";

static const char g_McRTOS_build_timestamp[] = "built " __DATE__ " " __TIME__;

/**
 * Per-cpu system threads:
 */
static const struct rtos_thread_creation_params g_rtos_system_threads[] =
{
    [RTOS_ROOT_SYSTEM_THREAD] =
    {
        .p_name_p = "McRTOS root thread",
        .p_function_p = rtos_root_thread_f,
        .p_function_arg_p = NULL,
        .p_priority = RTOS_ROOT_THREAD_PRIORITY,
        .p_console_channel = 0,
        .p_lcd_channel = 0,
        .p_thread_pp = NULL,
    },

    [RTOS_IDLE_SYSTEM_THREAD] =
    {
        .p_name_p = "McRTOS idle thread",
        .p_function_p = rtos_idle_thread_f,
        .p_function_arg_p = NULL,
        .p_priority = RTOS_IDLE_THREAD_PRIORITY,
        .p_console_channel = RTOS_CONSOLE_CHANNEL_NONE,
        .p_lcd_channel = RTOS_LCD_CHANNEL_NONE,
        .p_thread_pp = NULL,
    },

    [RTOS_COMMAND_LINE_SYSTEM_THREAD] =
    {
        .p_name_p = "McRTOS command line thread",
        .p_function_p = rtos_command_line_thread_f,
        .p_function_arg_p = NULL,
        .p_priority = RTOS_COMMAND_LINE_THREAD_PRIORITY,
        .p_console_channel = RTOS_COMMAND_LINE_CONSOLE_CHANNEL,
        .p_lcd_channel = RTOS_LCD_CHANNEL_NONE,
        .p_thread_pp = NULL,
    },

#if 0 // TODO
    [RTOS_TOUCH_SCREEN_SYSTEM_THREAD] =
    {
        .p_name_p = "McRTOS touch screen reader thread",
        .p_function_p = rtos_touch_screen_reader_thread_f,
        .p_function_arg_p = NULL,
        .p_priority = TOUCH_SCREEN_READER_THREAD_PRIORITY,
        .p_console_channel = 0,
        .p_lcd_channel =  0, //XXX RTOS_LCD_CHANNEL_NONE,
        .p_thread_pp = NULL,
    },

    [RTOS_BUTTONS_SYSTEM_THREAD] =
    {
        .p_name_p = "McRTOS buttons reader thread",
        .p_function_p = rtos_buttons_reader_thread_f,
        .p_function_arg_p = NULL,
        .p_priority = BUTTONS_READER_THREAD_PRIORITY,
        .p_console_channel = 0,
        .p_lcd_channel = RTOS_LCD_CHANNEL_NONE,
        .p_thread_pp = NULL,
    },

    [RTOS_TRIMPOT_SYSTEM_THREAD] =
    {
        .p_name_p = "McRTOS trimpot reader thread",
        .p_function_p = rtos_trimpot_reader_thread_f,
        .p_function_arg_p = NULL,
        .p_priority = TRIMPOT_READER_THREAD_PRIORITY,
        .p_console_channel = 0,
        .p_lcd_channel = RTOS_LCD_CHANNEL_NONE,
        .p_thread_pp = NULL,
    },
#endif
};

C_ASSERT(ARRAY_SIZE(g_rtos_system_threads) <= RTOS_NUM_SYSTEM_THREADS_PER_CPU);

/**
 * McRTOS global state variables
 */ 
static struct McRTOS g_McRTOS =
{
    .rts_signature = MCRTOS_SIGNATURE,

    .rts_next_free_app_thread_p = &g_McRTOS.rts_app_threads[0],

    .rts_next_free_app_timer_p = &g_McRTOS.rts_app_timers[0],

    .rts_next_free_app_mutex_p = &g_McRTOS.rts_app_mutexes[0],

    .rts_next_free_app_condvar_p = &g_McRTOS.rts_app_condvars[0],

    .rts_next_free_app_32bit_msg_channel_p = &g_McRTOS.rts_app_32bit_msg_channels[0],

    .rts_next_free_app_object_pool_p = &g_McRTOS.rts_app_object_pools[0],

#ifdef RTOS_USE_DRAM_FOR_APP_THREAD_STACKS
    .rts_next_free_app_thread_stack_p = 
        (struct rtos_thread_execution_stack *)RTOS_APP_THREAD_DRAM_STACKS_BASE_ADDR,
    
    .rts_app_threads_execution_stacks_p =
        (struct rtos_thread_execution_stack *)RTOS_APP_THREAD_DRAM_STACKS_BASE_ADDR,
#else
    .rts_next_free_app_thread_stack_p = &g_McRTOS.rts_app_threads_execution_stacks[0],
    
    .rts_app_threads_execution_stacks_p = g_McRTOS.rts_app_threads_execution_stacks,
#endif

    RTOS_CPU_CONTROLLER_INITIALIZER(0),
};

/**
 * Access to the McRTOS global structure should be done through this pointer,
 * in case we want to move the global structure to SDRAM
 */
struct McRTOS *const g_McRTOS_p = &g_McRTOS;


#ifdef DEBUG
/*
 * Check some of the compile-time initializations common to all CPU cores
 */
static void
check_mcrtos_common_compile_time_initializations(void)
{
#ifdef RTOS_USE_DRAM_FOR_APP_THREAD_STACKS
    DBG_ASSERT(
        g_McRTOS_p->rts_next_free_app_thread_stack_p ==
        (struct rtos_thread_execution_stack *)
            &g_sdram_map_p->sdr_rtos_app_thread_stacks[0],
        g_McRTOS_p->rts_next_free_app_thread_stack_p,
        &g_sdram_map_p->sdr_rtos_app_thread_stacks[0]);
#endif
}
#endif /* DEBUG */


static void
display_console_greetings(void)
{
    console_clear();
    console_printf("%s\n%s\n", g_McRTOS_version, g_McRTOS_build_timestamp);
}


static void
display_lcd_greetings(void)
{
    static const struct lcd_char_attributes lcd_char_attributes1 = 
    {
        .lcd_dot_size = 1,
        .lcd_foreground_color = LCD_COLOR_YELLOW,
        .lcd_background_color = LCD_COLOR_BLUE,
    };

    static const struct lcd_char_attributes lcd_char_attributes2 = 
    {
        .lcd_dot_size = 2,
        .lcd_foreground_color = LCD_COLOR_YELLOW,
        .lcd_background_color = LCD_COLOR_BLUE,
    };

    lcd_clear(LCD_COLOR_BLUE);
    lcd_printf(
        64, 64, &lcd_char_attributes2, "%s", g_McRTOS_version);
    lcd_printf(
        0, 96, &lcd_char_attributes1, 
        "             German Rivera\n"
        "       %s\n",
        g_McRTOS_build_timestamp);
}


/**
 * Main entry point of McRTOS. This function is to be invoked from the
 * reset exception handler or from the application's main() function, which
 * is assumed to be invoked from the reset exception handler, and therefore it
 * runs in privileged mode and with interrupts disabled.
 *
 * When this function is invoked, McRTOS takes control of the machine, and
 * this function only returns if there is an initialization error in McRTOS.
 *
 * @param   rtos_app_config_p Pointer to startup application configuration for
 *          the calling CPU core.
 *
 * @return  none
 */
void
rtos_startup( 
    _IN_ const struct rtos_per_cpu_startup_app_configuration *rtos_app_config_p)
{
    FDC_ASSERT_COMING_FROM_RESET();
    FDC_ASSERT_CPU_IS_LITTLE_ENDIAN();
    FDC_ASSERT(rtos_app_config_p != NULL, 0, 0);

    struct rtos_thread *rtos_thread_p;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();
    struct rtos_cpu_controller *cpu_controller_p =
                                    &g_McRTOS_p->rts_cpu_controllers[cpu_id];

    cpu_controller_p->cpc_app_config_p = rtos_app_config_p;

    /*
     * Initialize board hardware on CPU 0:
     */
    if (cpu_id == 0)
    {
#ifdef DEBUG
        /*
         * Check the compile-time initializations common to all CPU cores:
         */
        check_mcrtos_common_compile_time_initializations();
#endif

        board_init();

        /*
         * Calculate  approximate overhead for taking a measurement of time in
         * CPU clock cycles:
         */
        cpu_clock_cycles_t begin_cycles = get_cpu_clock_cycles();
        g_McRTOS_p->rts_cpu_cycles_measure_overhead =
            CPU_CLOCK_CYCLES_DELTA(begin_cycles, get_cpu_clock_cycles()) * 2;
    }

    /*
     * Initialize runnable thread queues for this CPU controller:
     */
    for (rtos_thread_prio_t i = 0; i < RTOS_NUM_THREAD_PRIORITIES; ++ i)
    {
        GLIST_NODE_INIT(
            &cpu_controller_p->cpc_runnable_thread_queues_anchors[i]);
    }

    /*
     * Initialize hash chains of the timer wheel for this CPU controller:
     */
    for (rtos_timer_wheel_spoke_index_t i = 0; i < RTOS_TIMER_WHEEL_NUM_SPOKES; ++ i)
    {
        GLIST_NODE_INIT(
            &cpu_controller_p->cpc_timer_wheel_hash_chains_anchors[i]);
    }

    /*
     * Create root system thread to continue system initialization in that thread:
     */
    rtos_thread_p = 
        &(cpu_controller_p->cpc_system_threads[RTOS_ROOT_SYSTEM_THREAD]);

    rtos_k_thread_init(
        &g_rtos_system_threads[RTOS_ROOT_SYSTEM_THREAD],
        &cpu_controller_p->cpc_system_threads_execution_stacks[RTOS_ROOT_SYSTEM_THREAD],
        cpu_id,
        true,
        RTOS_ROOT_SYSTEM_THREAD,
        rtos_thread_p);

    /*
     * Set the current execution context to be the root system thread context:
     */

    FDC_ASSERT(
        cpu_controller_p->cpc_current_execution_context_p == NULL,
        cpu_controller_p->cpc_current_execution_context_p, 
        cpu_controller_p);

    cpu_controller_p->cpc_current_execution_context_p =
        &(rtos_thread_p->thr_execution_context);
    
    cpu_controller_p->cpc_current_thread_p = rtos_thread_p;

    cpu_controller_p->cpc_startup_completed = true;

    /*
     * Invoke the thread scheduler to "switch out" to the root thread:
     *
     * NOTE: Although we have been running with interrupts disabled all
     * along since reset, we only start measuring the disable time here,
     * as all the previous code only executes at boot time, and it does 
     * not matter for how long we keep interrupts disabled before 
     * we start executing threads.
     */

    RTOS_START_INTERRUPTS_DISABLED_TIME_MEASURE();
    rtos_thread_scheduler();

    /*
     * We should never come here
     */
    FDC_ASSERT(false, 0, 0);
}


/**
 * McRTOS root thread function
 */
static fdc_error_t
rtos_root_thread_f(void *arg)
{
    FDC_ASSERT_PRIVILEGED_CPU_MODE_AND_INTERRUPTS_ENABLED();

    fdc_error_t fdc_error;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();
    struct rtos_cpu_controller *cpu_controller_p =
                                    &g_McRTOS_p->rts_cpu_controllers[cpu_id];

    const struct rtos_per_cpu_startup_app_configuration *rtos_app_config_p =
                                            cpu_controller_p->cpc_app_config_p;

    FDC_ASSERT(arg == NULL, arg, cpu_id);
    FDC_ASSERT(rtos_app_config_p != NULL, 0, 0);

    /*
     * Disable interrupts in the ARM core
     */
    cpu_status_register_t cpu_status_register = rtos_k_disable_cpu_interrupts();

    /*
     * Initialize console output mutex
     */ 
    rtos_k_mutex_init(
        "console output mutex",
        cpu_id,
        &cpu_controller_p->cpc_console_output_mutex);

    /*
     * Initialize LCD output mutex
     */ 
    rtos_k_mutex_init(
        "LCD output mutex",
        cpu_id,
        &cpu_controller_p->cpc_lcd_output_mutex);

    /*
     * Display greetings:
     */

    if (cpu_id == RTOS_CONSOLE_CPU_ID)
    {
        display_console_greetings();
    }

    if (cpu_id == RTOS_LCD_CPU_ID)
    {
        display_lcd_greetings();
    }

    console_printf("CPU core %u: %s started\n", cpu_id,
        g_rtos_system_threads[RTOS_ROOT_SYSTEM_THREAD].p_name_p);

    /*
     * Initialize tick timer interrupts for this CPU core:
     *
     * NOTE: Even if tick timer interrupts start coming right away,
     * we will not get interrupted yet, as we still have interrupts
     * disabled.
     */
    initialize_tick_timer(); 

    console_printf("CPU core %u: McRTOS tick timer started\n", cpu_id);

    /*
     * Create the other system threads for this CPU
     */ 
    for (uint8_t i = RTOS_IDLE_SYSTEM_THREAD; i < ARRAY_SIZE(g_rtos_system_threads); i ++)
    {
        struct rtos_thread *rtos_thread_p = &cpu_controller_p->cpc_system_threads[i];
        rtos_k_thread_init(
            &g_rtos_system_threads[i],
            &cpu_controller_p->cpc_system_threads_execution_stacks[i],
            cpu_id,
            true,
            i,
            rtos_thread_p);

        console_printf("CPU core %u: %s started\n", cpu_id,
            g_rtos_system_threads[i].p_name_p);
    }

    /*
     * Create pre-built application mutexes for this CPU core:
     */

    rtos_num_app_mutexes_t num_app_mutexes =
        rtos_app_config_p->stc_num_prebuilt_mutexes;

    for (rtos_num_app_mutexes_t i = 0; i < num_app_mutexes; i ++)
    {
        fdc_error = rtos_k_create_mutex(
                        &rtos_app_config_p->stc_prebuilt_mutexes_p[i]);

        if (fdc_error != 0)
        {
            console_printf(
                "CPU core %u: *** Error creating application mutex %u ***\n",
                cpu_id, i);

            fatal_error_handler(fdc_error);
        }

        console_printf("CPU core %u: %s created\n", cpu_id,
            rtos_app_config_p->stc_prebuilt_mutexes_p[i].p_name_p);

    }

    /*
     * Create pre-built application condvars for this CPU core:
     */

    rtos_num_app_condvars_t num_app_condvars =
        rtos_app_config_p->stc_num_prebuilt_condvars;

    for (rtos_num_app_condvars_t i = 0; i < num_app_condvars; i ++)
    {
        fdc_error = rtos_k_create_condvar(
                        &rtos_app_config_p->stc_prebuilt_condvars_p[i]);

        if (fdc_error != 0)
        {
            console_printf(
                "CPU core %u: *** Error creating application condvar %u ***\n",
                cpu_id, i);

            fatal_error_handler(fdc_error);
        }

        console_printf("CPU core %u: %s created\n", cpu_id,
            rtos_app_config_p->stc_prebuilt_condvars_p[i].p_name_p);
    }

    /*
     * Create auto-start application threads for this CPU core
     */

    rtos_num_app_threads_t num_app_threads =
        rtos_app_config_p->stc_num_autostart_threads;

    for (rtos_num_app_threads_t i = 0; i < num_app_threads; i ++)
    {
        fdc_error = rtos_k_create_thread(
                        &rtos_app_config_p->stc_autostart_threads_p[i]);

        if (fdc_error != 0)
        {
            console_printf(
                "CPU core %u: *** Error creating application thread %u ***\n",
                cpu_id, i);

            fatal_error_handler(fdc_error);
        }

        console_printf("CPU core %u: %s started\n", cpu_id,
            rtos_app_config_p->stc_autostart_threads_p[i].p_name_p);
    }
    
    /*
     * Restore previous interrupt masking in the ARM core
     */
    rtos_k_restore_cpu_interrupts(cpu_status_register);

    /*
     * Reset the "longest time interrupts disabled" to 0, as this 
     * is still boot time, and should not be taken into account.
     */
    cpu_controller_p->cpc_longest_time_interrupts_disabled = 0;

    for ( ; ; )
    {
        /*
         * Wait for critical work to do:
         *
         * NOTE: The root system thread is the highest priority thread
         * in the system and is only awoken wen something really urgent
         * needs to be done.
         */
        rtos_k_thread_condvar_wait_interrupt();
    
        /*
         * TODO
         */
    }

    fdc_error = CAPTURE_FDC_ERROR(
        "McRTOS root thread should not have terminated", cpu_id, 0);

    return fdc_error;
}


/**
 * McRTOS idle thread function
 */
static fdc_error_t
rtos_idle_thread_f(void *arg)
{
    FDC_ASSERT_PRIVILEGED_CPU_MODE_AND_INTERRUPTS_ENABLED();

    fdc_error_t fdc_error;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();
    struct rtos_cpu_controller *cpu_controller_p =
                                    &g_McRTOS_p->rts_cpu_controllers[cpu_id];

    FDC_ASSERT(arg == NULL, arg, cpu_id);
    FDC_ASSERT(cpu_controller_p->cpc_app_config_p != NULL, cpu_id, 0);

    rtos_idle_thread_hook_function_t *idle_thread_hook_function_p = 
        cpu_controller_p->cpc_app_config_p->stc_idle_thread_hook_function_p;

    for ( ; ; )
    {
        /*
         * Invoke application hook:
         */
        if (idle_thread_hook_function_p != NULL)
        {
            idle_thread_hook_function_p();
        }

#if 0 // XXX
        TODO("Implement this")
        /*
         * TODO: Stop generation of tick timer interrupts if there are no active
         * McRTOS timers
         */

        /*
         * Wait for interrupts:
         */
        wait_for_interrupts();

        TODO("Implement this")
        /*
         * TODO: Re-start generation of tick timer interrupts if it was stopped
         */
#endif
    }

    fdc_error = CAPTURE_FDC_ERROR(
        "McRTOS idle thread should not have terminated", cpu_id, 0);

    return fdc_error;
}


/**
 * Touchscreen reader thread
 */
static fdc_error_t
rtos_touch_screen_reader_thread_f(void *arg)
{
    lcd_color_t old_color;
    uint_fast8_t tile_row;
    uint_fast8_t tile_column;
    uint_fast16_t x;
    uint_fast16_t y;
    fdc_error_t fdc_error;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();

    FDC_ASSERT(arg == NULL, arg, cpu_id);

    console_printf("Initializing McRTOS touch screen sensing thread ...\n");

    init_touch_screen();

    for ( ; ; )
    {
        if (sense_touch_screen(TILE_WIDTH, &tile_row, &tile_column))
        {
            x = tile_column * TILE_WIDTH;
            y = tile_row * TILE_WIDTH;
            //rtos_mutex_acquire(g_lcd_output_mutex_p);
            old_color = lcd_draw_tile(x, y, LCD_COLOR_BRIGHT(LCD_COLOR_GREEN));
            rtos_thread_delay(200);
            (void)lcd_draw_tile(x, y, old_color);
            //rtos_mutex_release(g_lcd_output_mutex_p);
        } 
        else
        {
            rtos_thread_delay(20);
        }
    }   

    fdc_error = CAPTURE_FDC_ERROR(
        "McRTOS touch screen thread should not have terminated",
        cpu_id, rtos_thread_self());

    return fdc_error;
}


TODO("Remove these variables")
volatile uint32_t tile_cursor_index = 0;
volatile uint32_t same_tile_count = 0;

/**
 * Buttons reader thread
 */
static fdc_error_t
rtos_buttons_reader_thread_f(void *arg)
{
    lcd_color_t old_color;
    uint32_t buttons_pressed;
    fdc_error_t fdc_error;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();

    FDC_ASSERT(arg == NULL, arg, cpu_id);

    console_printf("Initializing McRTOS buttons reader thread ...\n");

    init_buttons(g_buttons_device_p);

    for ( ; ; )
    {
        buttons_pressed = read_buttons(g_buttons_device_p);
        
        if (buttons_pressed & BUTTON1_PRESSED_MASK)
        {
            old_color = lcd_draw_tile(0, 1*TILE_WIDTH, LCD_COLOR_BRIGHT(LCD_COLOR_CYAN));
            rtos_thread_delay(200);
            (void)lcd_draw_tile(0, 1*TILE_WIDTH, old_color);

            ATOMIC_POST_INCREMENT_UINT32(&tile_cursor_index);
            same_tile_count = 0;
        }

        if ((buttons_pressed & BUTTON2_PRESSED_MASK) != 0)
        {
            old_color = lcd_draw_tile(0, 0*TILE_WIDTH, LCD_COLOR_BRIGHT(LCD_COLOR_MAGENTA));
            rtos_thread_delay(200);
            (void)lcd_draw_tile(0, 0*TILE_WIDTH, old_color);

            if (tile_cursor_index > 0)
            {
                ATOMIC_POST_DECREMENT_UINT32(&tile_cursor_index);
                same_tile_count = 0;
            }
        }
    } 

    fdc_error = CAPTURE_FDC_ERROR(
        "McRTOS buttons reader thread should not have terminated",
        cpu_id, rtos_thread_self());

    return fdc_error;
}


/**
 * Trimpot reader thread
 */
static fdc_error_t
rtos_trimpot_reader_thread_f(void *arg)
{
    uint32_t trimpot_reading;
    uint32_t old_trimpot_reading;
    fdc_error_t fdc_error;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();

    FDC_ASSERT(arg == NULL, arg, cpu_id);

    console_printf("Initializing McRTOS trimpot sensing thread ...\n");

    init_trimpot();

    old_trimpot_reading = 0;
    for ( ; ; )
    {
        trimpot_reading = read_trimpot();
        if (trimpot_reading != old_trimpot_reading)
        {
            old_trimpot_reading = trimpot_reading;
        }
        
        rtos_thread_delay(250);
    }   

    fdc_error = CAPTURE_FDC_ERROR(
        "McRTOS trimpot sensing thread should not have terminated",
        cpu_id, rtos_thread_self());

    return fdc_error;
}


static fdc_error_t
rtos_command_line_thread_f(void *arg)
{
    fdc_error_t fdc_error;
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();

    FDC_ASSERT(arg == NULL, arg, cpu_id);

    for ( ; ; )
    {
        uint8_t c = rtos_console_getchar(true);

        if (c != CTRL_C)
        {
            continue;
        }

        rtos_console_channels_t old_console_channel = 
            g_McRTOS_p->rts_current_console_channel;

        g_McRTOS_p->rts_current_console_channel = RTOS_COMMAND_LINE_CONSOLE_CHANNEL;

        console_clear();
        McRTOS_display_help();

        bool quit = false;

        do {
            console_printf("McRTOS> ");
            c = rtos_console_getchar(true);
            switch (c)
            {
                case 's':
                    McRTOS_display_stats();
                    break;
                case 'q':
                    quit = true;
                    break;

                default:
                    McRTOS_display_help();
                    break;
            }
        } while (!quit);

        console_clear();
        g_McRTOS_p->rts_current_console_channel = old_console_channel;
    }

    fdc_error = CAPTURE_FDC_ERROR(
        "McRTOS command line thread should not have terminated",
        cpu_id, rtos_thread_self());

    return fdc_error;
}


static void
McRTOS_display_help(void)
{
    console_printf("\nMcRTOS commands\n");
    console_printf("\ts - display McRTOS stats (until any key is pressed)\n");
    console_printf("\tq - quit McRTOS command mode\n");
    console_printf("\n");
}


static void
McRTOS_display_stats(void)
{
    cpu_id_t cpu_id = SOC_GET_CURRENT_CPU_ID();
    struct rtos_cpu_controller *cpu_controller_p =
        &g_McRTOS_p->rts_cpu_controllers[cpu_id];

#if 0
    uint8_t c;

    /*
     * Flush console input:
     */
    do {
        c = rtos_console_getchar(false);
    } while (c != '\0');
#endif

    for ( ; ; )
    {
        console_clear();
        console_printf("McRTOS stats for CPU core %u:\n\n", cpu_id);

        struct glist_node *context_node_p;

        console_printf(
            "Context    Name                          Type  CPU  Switched-in CPU         Intr. disabled Switched-out\n"
            "address                                        mode count       usage       time           history\n"
            "========== ============================= ==== ===== =========== =========== ============== ============\n");

        GLIST_FOR_EACH_NODE(
            context_node_p,
            &cpu_controller_p->cpc_execution_contexts_list_anchor)
        {
            struct rtos_execution_context *context_p = 
                GLIST_NODE_ENTRY(
                    context_node_p, struct rtos_execution_context, ctx_list_node);

            const char *ctx_type_str =
                (context_p->ctx_context_type == RTOS_INTERRUPT_CONTEXT) ?
                    "I" : "T";

            console_printf(
                "0x%x %s                            %s   %u    %u          %u          %u             0x%x\n",
                context_p,
                context_p->ctx_name_p,
                ctx_type_str,
                context_p->ctx_cpu_mode,
                context_p->ctx_switched_in_counter,
                context_p->ctx_accumulated_cpu_usage,
                context_p->ctx_longest_time_interrupts_disabled,
                context_p->ctx_switched_out_reason_history);
        }
  
#if 0
        rtos_thread_delay(2000);
        uint8_t c = rtos_console_getchar(false);
        if (c == CTRL_C)
        {
            console_clear();
            break;
        }
#else
        break;
#endif
    }
}
